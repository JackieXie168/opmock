/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
/*
 * XmlLoader.java
 * Copyright (C) Pascal Ognibene 2010-2012 <pognibene@gmail.com>
 * 
 *  is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 *  is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.opmock;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class XmlLoader {

	/**
	 * Load the XML file generated by SWIG for a C or C++ header file then
	 * generate stubs and utility functions or classes
	 * 
	 * @param input
	 * @return a list of C functions
	 */
	public List<CFunction> processFileForC(String input) {

		Document doc = loadSwigXml(input);
		Element top = (Element) doc.getFirstChild();
		List<CFunction> functions = new ArrayList<CFunction>();

		// Browse the list of nodes
		List<Element> nodeLst = getElementsWithName(top, "include");
		for (Element includeEl : nodeLst) {
			List<Element> cdeclLst = getElementsWithName(includeEl, "cdecl");

			// Get all C functions
			// in C mode there are no namespaces, so just pass an empty
			// namespace
			for (Element cdeclEl : cdeclLst) {
				CFunction oneFunction = getFunctionDescription(cdeclEl, "");
				if (oneFunction != null) {
					functions.add(oneFunction);
				}
			}
		}
		return functions;
	}

	/**
	 * return the first child element with this name
	 * 
	 * @param oneNode
	 * @param name
	 * @return
	 */
	private Element getElementWithName(Node oneNode, String name) {
		List<Element> res = new ArrayList<Element>();
		NodeList list = oneNode.getChildNodes();
		for (int i = 0; i < list.getLength(); i++) {
			Node node = list.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				Element element = (Element) node;
				if (element.getNodeName().compareTo(name) == 0) {
					res.add(element);
				}
			}
		}
		if (res.size() > 0) {
			return res.get(0);
		} else {
			return null;
		}
	}

	/**
	 * return the list of first level child elements with this name
	 * 
	 * @param oneNode
	 * @param name
	 * @return
	 */
	private List<Element> getElementsWithName(Node oneNode, String name) {
		List<Element> res = new ArrayList<Element>();
		NodeList list = oneNode.getChildNodes();
		for (int i = 0; i < list.getLength(); i++) {
			Node node = list.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				Element element = (Element) node;
				if (element.getNodeName().compareTo(name) == 0) {
					res.add(element);
				}
			}
		}
		return res;
	}

	/**
	 * Get a function description, either C or C++
	 * 
	 * @param elCdecl
	 * @param ns
	 *            the current namespace, like foo:boo:poo
	 * @return
	 */
	private CFunction getFunctionDescription(Element elCdecl, String ns) {
		CFunction newFunc = null;

		// get the element name, check if it's a cdecl or a constructor
		// or a destructor or a function template
		boolean isConstructor = false;
		boolean isDestructor = false;
		boolean isTemplate = false;
		boolean isCopyConstructor = false;
		boolean isFunction = false;
		boolean isConst = false;
		int nbDefaultParam = 0;
		String code = "";

		if (elCdecl.getNodeName().compareTo("constructor") == 0) {
			isConstructor = true;
		} else if (elCdecl.getNodeName().compareTo("destructor") == 0) {
			isDestructor = true;
		} else if (elCdecl.getNodeName().compareTo("template") == 0) {
			isTemplate = true;
		}

		Element attributes = getElementWithName(elCdecl, "attributelist");
		if (attributes != null) {

			// get the list of attribute elements
			// and analyse them
			String functionName = "";
			String retVal = "";
			String signature = "";
			String storage = "";
			boolean isMember = false;
			String access = "";
			boolean isVariadic = false;

			List<Element> attributeLst = getElementsWithName(attributes,
					"attribute");

			// get the attributes
			for (Element attributeElmnt : attributeLst) {

				String attrName = attributeElmnt.getAttribute("name");
				String attrValue = attributeElmnt.getAttribute("value");

				if (attrName.compareTo("name") == 0) {
					functionName = attrValue;
				} else if (attrName.compareTo("kind") == 0) {
					if (attrValue.compareTo("function") == 0) {
						isFunction = true;
					}
				} else if (attrName.compareTo("decl") == 0) {
					signature = attrValue;
				} else if (attrName.compareTo("type") == 0) {
					retVal = attrValue;
				} else if (attrName.compareTo("storage") == 0) {
					// storage can't be at the same time virtual and static
					storage = attrValue;
				} else if (attrName.compareTo("ismember") == 0) {
					if (attrValue.compareTo("1") == 0) {
						isMember = true;
					}
				} else if (attrName.compareTo("code") == 0) {
					code = attrValue;
				} else if (attrName.compareTo("access") == 0) {
					access = attrValue;
				} else if (attrName.compareTo("view") == 0) {
					if (attrValue.compareTo("constructorDeclaration") == 0) {
						isConstructor = true;
					} else if (attrValue.compareTo("destructorDeclaration") == 0) {
						isDestructor = true;
					}
				} else if (attrName.compareTo("copy_constructor") == 0) {
					if (attrValue.compareTo("1") == 0) {
						isCopyConstructor = true;
					} else {
						isCopyConstructor = false;
					}
				} else if (attrName.compareTo("qualifier") == 0) {
					if (attrValue.compareTo("q(const).") == 0) {
						isConst = true;
					} else {
						isConst = false;
					}
				}

			}

			// did we find a C or C++ function ?
			if (isFunction || isConstructor || isDestructor || isTemplate) {

				// extract the return value
				// valid for a function only, not for a constructor
				// or a destructor.
				if (isFunction) {
					retVal = cTransformParameter(retVal);
					String hasPtr = cReturnPtr(signature);
					if (hasPtr.length() > 0) {
						retVal += " " + hasPtr;
					}
				}

				List<CParameter> listParams = new ArrayList<CParameter>();

				// extract parameters : name, type
				Element params = getElementWithName(attributes, "parmlist");
				if (params != null) {

					List<Element> parmLst = getElementsWithName(params, "parm");
					for (Element parmElmnt : parmLst) {

						String parmName = "";
						String lParmName = "";
						String paramDefaultVal = null;
						CParameter newParam = null;
						Element attributelistElmnt = getElementWithName(
								parmElmnt, "attributelist");

						List<Element> attributelistLst = getElementsWithName(
								attributelistElmnt, "attribute");
						for (Element attributeElmnt : attributelistLst) {

							String attrName = attributeElmnt
									.getAttribute("name");
							String attrValue = attributeElmnt
									.getAttribute("value");

							if (attrName.compareTo("name") == 0) {
								parmName = attrValue.trim();
							} else if (attrName.compareTo("lname") == 0) {
								lParmName = attrValue.trim();
							} else if (attrName.compareTo("value") == 0) {
								nbDefaultParam++;
							} else if (attrName.compareTo("type") == 0) {
								// convert the parameter to C or C++ notation
								// pointers in the XML tree show like:
								// p.p.char for char ** or r.p.int for int *&

								// ignore parameters of type void
								// should really never be used but some people
								// insist on using this notation
								if (attrValue.trim().compareTo("void") != 0) {
									String oneParam = getParameterForC(
											attrValue, parmName);

									// remove <( )> combinations that seem
									// to result
									// from a template parameter in Swig.
									// Replace them
									// with < >
									oneParam = oneParam.replaceAll("<\\(", "<");
									oneParam = oneParam.replaceAll("\\)>", ">");

									newParam = new CParameter();
									newParam.value = oneParam;
									newParam.desc = attrValue;

									newParam.name = parmName;
									listParams.add(newParam);
								}
								if (attrValue.indexOf("...") != -1) {
									isVariadic = true;
								}
							}
						}

						// name can be empty or null if the coder uses
						// anonymous parameters or void parameters.
						// check that and use instead the lname if
						// this is the case
						if (newParam != null) {
							if (newParam.name.length() == 0) {
								newParam.name = lParmName;
								newParam.hasName = false;
								// warn as this is a bad pattern
								System.out
										.println("WARNING : anonymous parameter in the function "
												+ functionName
												+ ", work around with a synthetized name.\n"
												+ "You should fix your header to match the implementation prototype.");
							}
						}
					}
				}

				String[] nameTab = functionName.split("::");
				if (isConstructor || isDestructor) {
					functionName = nameTab[nameTab.length - 1];
				}

				if (storage.compareTo("typedef") != 0) {
					if (isVariadic) {
						System.out
								.println("WARNING : The function "
										+ functionName
										+ " is variadic. Can't mock this yet, skipped.");
					} else {

						if (code.length() == 0) {
							newFunc = new CFunction();
							newFunc.functionName = functionName;
							// remove spurious () that are introduced by Swig
							// when the return type is a templated type
							retVal = retVal.replaceAll("\\(", "");
							retVal = retVal.replaceAll("\\)", "");
								
							newFunc.returnValue = retVal;
							newFunc.params = listParams;
							newFunc.storage = storage;
							newFunc.access = access;
							newFunc.isMember = isMember;
							newFunc.nameSpace = ns;
							newFunc.nbDefaultParam = nbDefaultParam;
							newFunc.isConst = isConst;
						} else {
							System.out
									.println("WARNING : function or constructor/destructor "
											+ functionName
											+ " is inlined in a header, can't mock");
							newFunc = null;
						}
						// newFunc.isVariadic = isVariadic;

						// filter out constructors or destructors
						// created by swig. Bleh, ugly, but swig does ugly
						// things also
						if ((isConstructor || isDestructor)
								&& (isMember == false))
							newFunc = null;

						// I don't handle operator overloads
						// so let's trash them
						if (functionName.indexOf("operator ") != -1) {
							newFunc = null;
						}
					}
				}
			}
		}
		return newFunc;
	}

	private String getParameterForC(String attrValue, String parmName) {

		// check if the parameter is a vararg
		int index = attrValue.indexOf("...");
		if (index != -1) {
			return "...";
		}

		// check if the parameter contains a function pointer
		// as this is more complex to parse
		if (attrValue.indexOf("p.f(") != -1) {
			return getFunctionPointerParameter(attrValue, parmName);
		}

		// check if the parameter is simply void
		// in which case I return a null string, because this is
		// actually *not* a parameter
		if (attrValue.trim().compareTo("void") == 0) {
			return null;
		}

		// r.p.p.q(const).int
		// or a().a(10).p.MaStruct should result in MaStruct *my_array[][10]

		String result = "";
		String constLeft = "";
		String constRight = "";
		String arrayString = "";
		String ptAndRef = "";
		int firstIndex = 0;
		String tmp = attrValue.replace('.', '&');
		String[] tab = tmp.split("&");
		int lastIndex = tab.length - 2;

		// check if the parameter declaration includes pointers
		// in which case I can use twice the 'const' keyword
		boolean hasPointer = false;
		boolean hasReference = false;

		for (index = 0; index < tab.length; index++) {
			if (tab[index].compareTo("p") == 0) {
				hasPointer = true;
				break;
			}
		}

		// check if the parameter declaration includes arrays
		for (index = 0; index < tab.length; index++) {
			if (tab[index].startsWith("a(")) {
				arrayString += "["
						+ tab[index].subSequence(2, tab[index].length() - 1)
						+ "]";
				firstIndex++;
			}
		}

		// check if there's a reference
		if (tab[firstIndex].compareTo("r") == 0) {
			hasReference = true;
			firstIndex++;
		}

		if (tab.length > 0) {
			// the type is always the last index in the array
			String parmType = tab[tab.length - 1];

			if (tab[firstIndex].compareTo("q(const)") == 0) {
				// if the argument has pointers then the first const
				// is to be placed just before the parameter name
				if (hasPointer == true) {
					constRight = "const";
				}
				// but if the argument has no pointer then the first const
				// is to be placed at the beginning of the argument
				else {
					constLeft = "const";
				}
				firstIndex += 1;// skip the const for parameter analysis
			}

			// now analyze the potential second const
			// it can be present *only* if the argument has pointers
			if (hasPointer == true) {
				if (tab[lastIndex].compareTo("q(const)") == 0) {
					constLeft = "const";
					lastIndex -= 1;// skip the const
				}
			}

			// I have first index and last index of additional infos
			// like pointers and references
			for (index = firstIndex; index <= lastIndex; index++) {
				if (tab[index].compareTo("p") == 0) {
					ptAndRef = "*" + ptAndRef;
				}
			}

			// build the result
			if (constLeft.length() > 0)
				result += constLeft + " ";
			result += parmType + " ";
			if (ptAndRef.length() > 0)
				result += ptAndRef + " ";
			if (hasReference == true)
				result += "& ";
			if (constRight.length() > 0)
				result += constRight + " ";
			result += parmName;
			if (arrayString.length() > 0)
				result += " " + arrayString;
		}
		return result;
	}

	private String getFunctionPointerParameter(String attrValue, String parmName) {

		// extract the parameter string
		// beginning is after p.f(
		// end is is the closing parenthesis that match the opening one
		// and I need to skip all parenthesis that may be in the middle
		int idxParam = 4;
		int parenmatch = 1;// because I have one opening parenthesis
		int indexEnd = 0;
		boolean stopIt = false;

		while (stopIt != true) {
			char oneChar = attrValue.charAt(idxParam);
			if (oneChar == '(')
				parenmatch++;
			if (oneChar == ')')
				parenmatch--;

			if (parenmatch == 0) {
				indexEnd = idxParam;
				stopIt = true;
			}

			idxParam++;
			if (idxParam >= attrValue.length())
				stopIt = true;
		}

		String parameters = attrValue.substring(4, indexEnd);

		// split this parameter string then get each parameter separately
		String[] paramTab = parameters.split(",");
		List<String> paramList = new ArrayList<String>();
		for (int i = 0; i < paramTab.length; i++) {
			String argName = "arg" + (i + 1);
			String newParam = getParameterForC(paramTab[i], argName);
			if (newParam != null) {
				paramList.add(newParam);
			}
		}

		// the function must have a return type (even if it's void)
		// extract the return value
		String tmp = attrValue.replace('.', '&');
		paramTab = tmp.split("&");
		String returnType = paramTab[paramTab.length - 1];

		// extract the pointers or references if there are some
		String hasPtr = cReturnPtr(attrValue.substring(indexEnd));

		// build the parameter signature
		String res = returnType;
		if (hasPtr.length() > 0)
			res += " " + hasPtr;
		res += " (*" + parmName + ")(";
		// parameters
		Iterator<String> itr = paramList.iterator();
		while (itr.hasNext()) {
			String s = itr.next();
			res += s;
			if (itr.hasNext()) {
				res += ", ";
			}
		}
		res += ")";

		return res;
	}

	private Document loadSwigXml(String input) {
		File file = new File(input);
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		Document doc = null;

		try {
			DocumentBuilder db = dbf.newDocumentBuilder();
			doc = db.parse(file);
			doc.getDocumentElement().normalize();
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
		return doc;
	}

	/*
	 * @retVal signature of the function
	 */
	private String cReturnPtr(String retVal) {

		// just find the number of pointers declared in the signature
		// after the closing parenthesis
		int index = retVal.lastIndexOf(").");
		if (index + 2 < retVal.length() - 1) {
			String end = retVal.substring(index + 2);

			// TODO le code est presque identique mais pas tout à fait
			// avec la fonction d'en dessous
			String tmp = end.replace('.', '&');
			String ptAndRef = "";
			String[] tab = tmp.split("&");

			if (tab.length > 0) {
				for (int i = 0; i < tab.length; i++) {
					if (tab[i].compareTo("p") == 0) {
						ptAndRef = "*" + ptAndRef;
					} else if (tab[i].compareTo("r") == 0) {
						ptAndRef = "&" + ptAndRef;
					}
				}
			}
			return ptAndRef;

		} else {
			return "";
		}
	}

	/*
	 * From a string like p.p.char, generate a string like char ** (valid C
	 * notation)
	 */
	private String cTransformParameter(String attrValue) {
		// check if the parameter is a vararg
		int index = attrValue.indexOf("...");
		if (index != -1) {
			return "...";
		}

		// r.p.p.q(const).int
		String result = "";
		String tmp = attrValue.replace('.', '&');
		String isConst = "";

		String ptAndRef = "";
		String[] tab = tmp.split("&");

		if (tab.length > 1) {
			for (int i = 0; i < tab.length; i++) {
				if (tab[i].compareTo("p") == 0) {
					ptAndRef = "*" + ptAndRef;
				} else if (tab[i].compareTo("r") == 0) {
					ptAndRef = "&" + ptAndRef;
				} else if (tab[i].compareTo("q(const)") == 0) {
					isConst = "const ";
				}
			}
		}
		if (ptAndRef.length() > 0) {
			result = ptAndRef + " ";
		}
		if (tab.length > 0) {
			result = tab[tab.length - 1] + " " + result;
		} else {
			result = tmp;
		}
		result = isConst + result;
		result = result.trim();
		//
		// // TODO other qualifiers ? volatile, static,, register?
		return result;
	}

	public List<CppClass> processFileForCpp(String input,
			List<CFunction> functions, List<CppClass> classes,
			List<CFunction> functionTemplates, List<CppClass> classTemplates) {

		Document doc = loadSwigXml(input);
		Element top = (Element) doc.getFirstChild();

		// Browse the top list of nodes
		List<Element> includeLst = getElementsWithName(top, "include");
		for (Element includeElmnt : includeLst) {
			findClassesInNamespace(includeElmnt, classes);
			findTemplatesInNamespace(includeElmnt, functionTemplates, "");
			// TODO rechercher les templates de fonction
			// mais le code est à peu près commun avec le code des fonctions
			// et puis faire la même chose pour les templates de classe?
			findFunctionsInNamespace(includeElmnt, functions, "");

			// remove functions that are present multiple times because
			// they accept default values for parameters
			removeFunctionsWithDefaultParameters(functions);

			// remove methods in classes if they accept default parameters
			for (CppClass oneClass : classes) {
				removeFunctionsWithDefaultParameters(oneClass.functions);
				removeFunctionsWithDefaultParameters(oneClass.constructors);
				removeFunctionsWithDefaultParameters(oneClass.destructors);
			}

			HashSet<String> sset = new HashSet<String>();

			for (CFunction func : functions) {

				// if the function storage is 'extern", remove it,
				// otherwise we may get link time problems
				if (func.storage.compareTo("extern") == 0) {
					func.storage = "";
				}

				int overload_count = 0;
				String fname = func.functionName;
				if (!sset.contains(fname)) {

					// add the function to the set
					sset.add(fname);

					// inner loop for all overloads of this function
					for (CFunction func2 : functions) {
						if (func2.functionName.compareTo(fname) == 0) {
							func2.overload = overload_count;
							overload_count++;

						}
					}
				}
			}
		}
		return classes;
	}

	/**
	 * swig will generate N functions for a single function if it has default
	 * values for parameters. As a consequence I would generate it N times,
	 * which is a bug. I hence need to filter functions and keep only the one
	 * with the most parameters, if at least one parameter has a default value
	 * in this function.
	 * 
	 * @param functions
	 */
	private void removeFunctionsWithDefaultParameters(List<CFunction> functions) {
		// ca va marcher pour les fonctions. mais pour une classe
		// il me faudra le prefix (namespace+nom de classe) pour différentier
		// les fonctions
		List<CFunction> toRemove = new ArrayList<CFunction>();

		for (CFunction func : functions) {
			if (func.nbDefaultParam > 0) {
				functionDefaultRemoval(func, toRemove, functions);
			}
		}

		// remove this functions from the generation list
		for (CFunction func : toRemove) {
			functions.remove(func);
		}
	}

	private void functionDefaultRemoval(CFunction func,
			List<CFunction> toRemove, List<CFunction> functions) {

		/*
		 * look for functions of the same name. Of course must not be the same
		 * function
		 */
		CFunction longestFunction = func;

		for (CFunction func2 : functions) {
			if (func2 != func) {
				if (func2.functionName.compareTo(func.functionName) == 0) {
					// check if the first parameters, with no default value,
					// are the same for both functions
					if (sameStartingParameters(func, func2)) {
						if (func2.params.size() > func.params.size()) {
							longestFunction = func2;
						}
					}
				}
			}
		}

		// we have the function with the most parameters and the correct
		// signature
		// This one we'll keep for code generation, but we "unmark" the variable
		// parameters
		int defaultParams = longestFunction.nbDefaultParam;

		for (int i = 0; i < defaultParams; i++) {
			for (CFunction func2 : functions) {
				if (func2.functionName.compareTo(longestFunction.functionName) == 0) {
					if (sameStartingParameters(func2, longestFunction)) {
						if (func2.nbDefaultParam == i) {
							if (!toRemove.contains(func2)) {
								toRemove.add(func2);
							}
						}
					}
				}
			}
		}
	}

	private boolean sameStartingParameters(CFunction func, CFunction func2) {
		// both functions must have the same number of parameters with no
		// default value
		if ((func.params.size() - func.nbDefaultParam) != (func2.params.size() - func2.nbDefaultParam)) {
			return false;
		}

		// both functions must have the same types for the starting parameters
		int nbStartParams = func.params.size() - func.nbDefaultParam;
		for (int i = 0; i < nbStartParams; i++) {
			if (func.params.get(i).value.compareTo(func.params.get(i).value) != 0) {
				return false;
			}
		}
		return true;
	}

	private void findFunctionsInNamespace(Element elInclude,
			List<CFunction> functions, String ns) {
		// TODO factorize with template functions
		String nodeType = elInclude.getNodeName();
		if (nodeType.compareTo("namespace") == 0) {

			String thisNamespace = "";
			Element attributes = getElementWithName(elInclude, "attributelist");
			if (attributes != null) {
				List<Element> attributeLst = getElementsWithName(attributes,
						"attribute");
				for (Element attributeElmnt : attributeLst) {
					String attrName = attributeElmnt.getAttribute("name");
					String attrValue = attributeElmnt.getAttribute("value");

					if (attrName.compareTo("name") == 0) {
						thisNamespace = attrValue;
					}
				}
			}

			if (ns.length() == 0) {
				ns += thisNamespace;
			} else {
				ns += "::" + thisNamespace;
			}
		}

		List<Element> tLst = getElementsWithName(elInclude, "cdecl");

		// check if this is a function template or a class template
		for (Element tElmnt : tLst) {
			CFunction oneFunction = getFunctionDescription(tElmnt, ns);
			if (oneFunction != null) {
				functions.add(oneFunction);
			}
		}

		List<Element> namespaceLst = getElementsWithName(elInclude, "namespace");
		for (Element namespaceElmnt : namespaceLst) {
			findFunctionsInNamespace(namespaceElmnt, functions, ns);
		}
	}

	/**
	 * 
	 * @param elInclude
	 * @param fTemplates
	 * @param ns
	 *            the current namespace as ::foo::boo
	 */
	private void findTemplatesInNamespace(Element elInclude,
			List<CFunction> fTemplates, String ns) {
		// TODO en cours pour les templates de fonction

		String nodeType = elInclude.getNodeName();
		if (nodeType.compareTo("namespace") == 0) {

			// must pick the namespace name and built the full scope of the
			// template, as it is not retained by swig
			String thisNamespace = "";
			Element attributes = getElementWithName(elInclude, "attributelist");
			if (attributes != null) {
				List<Element> attributeLst = getElementsWithName(attributes,
						"attribute");
				for (Element attributeElmnt : attributeLst) {
					String attrName = attributeElmnt.getAttribute("name");
					String attrValue = attributeElmnt.getAttribute("value");

					if (attrName.compareTo("name") == 0) {
						thisNamespace = attrValue;
					}
				}
			}

			if (ns.length() == 0) {
				ns += thisNamespace;
			} else {
				ns += "::" + thisNamespace;
			}
		}

		List<Element> tLst = getElementsWithName(elInclude, "template");

		// check if this is a function template or a class template
		for (Element tElmnt : tLst) {
			boolean isTemplateFunc = false;
			boolean isTemplateClass = false;

			Element attributes = getElementWithName(tElmnt, "attributelist");
			if (attributes != null) {
				List<Element> attributeLst = getElementsWithName(attributes,
						"attribute");
				for (Element attributeElmnt : attributeLst) {
					String attrName = attributeElmnt.getAttribute("name");
					String attrValue = attributeElmnt.getAttribute("value");

					if (attrName.compareTo("templatetype") == 0) {
						if (attrValue.compareTo("cdecl") == 0) {
							isTemplateFunc = true;
						} else if (attrValue.compareTo("class") == 0) {
							isTemplateClass = true;
						}
					}
				}
			}
			if (isTemplateFunc) {
				CFunction oneFunction = getFunctionDescription(tElmnt, ns);
				if (oneFunction != null) {
					fTemplates.add(oneFunction);
				}
			}
		}

		List<Element> namespaceLst = getElementsWithName(elInclude, "namespace");
		for (Element namespaceElmnt : namespaceLst) {
			findTemplatesInNamespace(namespaceElmnt, fTemplates, ns);
		}
	}

	private void findClassesInNamespace(Element elInclude,
			List<CppClass> classes) {

		// look for classes at this level
		// I don't look for nested classes as they're not supported well by swig
		List<Element> classLst = getElementsWithName(elInclude, "class");

		for (Element classElmnt : classLst) {

			Element attributes = getElementWithName(classElmnt, "attributelist");
			if (attributes != null) {

				String className = "";
				boolean isClass = false;

				List<Element> attributeLst = getElementsWithName(attributes,
						"attribute");

				for (Element attributeElmnt : attributeLst) {

					// get the attributes
					String attrName = attributeElmnt.getAttribute("name");
					String attrValue = attributeElmnt.getAttribute("value");

					if (attrName.compareTo("name") == 0) {
						// the namespace is embedded in the class name
						className = attrValue;
					} else if (attrName.compareTo("kind") == 0) {
						if (attrValue.compareTo("class") == 0) {
							isClass = true;
						}
					}
				}

				// ok, is it a class? If yes, then get the operations and the
				// parameters. We'll use this to overload the class in the mock.
				if (isClass) {
					CppClass newClass = new CppClass();
					newClass.className = className;
					classes.add(newClass);

					List<CFunction> functions = new ArrayList<CFunction>();

					// Get all CPP functions
					List<Element> cdeclLst = getElementsWithName(classElmnt,
							"cdecl");
					for (Element cdeclElmnt : cdeclLst) {

						CFunction oneFunction = getFunctionDescription(
								cdeclElmnt, "");
						if (oneFunction != null) {
							functions.add(oneFunction);
						}
					}
					newClass.functions = functions;

					// find all constructors
					List<CFunction> constructors = new ArrayList<CFunction>();
					List<Element> constructorLst = getElementsWithName(
							classElmnt, "constructor");
					for (Element constructorElmnt : constructorLst) {
						CFunction oneFunction = getFunctionDescription(
								constructorElmnt, "");
						if (oneFunction != null) {
							constructors.add(oneFunction);
						}
					}
					newClass.constructors = constructors;

					// find all destructors
					List<CFunction> destructors = new ArrayList<CFunction>();
					List<Element> destructorLst = getElementsWithName(
							classElmnt, "destructor");
					for (Element destructorElmnt : destructorLst) {
						CFunction oneFunction = getFunctionDescription(
								destructorElmnt, "");
						if (oneFunction != null) {
							// if (oneFunction.access.compareTo("public") != 0)
							// {
							// System.out.println("WARNING : destructor "
							// + className + "::"
							// + oneFunction.functionName + " is "
							// + oneFunction.access
							// + " so it can't be mocked.\n");
							// } else {
							destructors.add(oneFunction);
							// }
						}
					}
					newClass.destructors = destructors;

					// uniquify functions, destructors, and constructors, in
					// case
					// they're overloaded. This is used to generate unique names
					// for the structures required by the mocks
					int hash_count = 0;
					HashMap<String, CFunction> hmap = new HashMap<String, CFunction>();
					for (CFunction oneFunc : newClass.functions) {
						if (hmap.containsKey(oneFunc.functionName)) {
							hash_count++;
							oneFunc.uid = "_" + Integer.toString(hash_count);
						}
						// key not here, insert the function, and the function
						// is not "uniquified"
						else {
							hmap.put(oneFunc.functionName, oneFunc);
						}
					}

					// same for constructors
					hash_count = 0;
					hmap = new HashMap<String, CFunction>();
					for (CFunction oneFunc : newClass.constructors) {
						if (hmap.containsKey(oneFunc.functionName)) {
							hash_count++;
							oneFunc.uid = "_" + Integer.toString(hash_count);
						} else {
							hmap.put(oneFunc.functionName, oneFunc);
						}
					}

					// same for destructors
					hash_count = 0;
					hmap = new HashMap<String, CFunction>();
					for (CFunction oneFunc : newClass.destructors) {
						if (hmap.containsKey(oneFunc.functionName)) {
							hash_count++;
							oneFunc.uid = "_" + Integer.toString(hash_count);
						} else {
							hmap.put(oneFunc.functionName, oneFunc);
						}
					}
				}
			}
		}

		// now check if I have declared namespaces at this level
		// if yes, find recursively all classes and namespaces
		List<Element> namespaceLst = getElementsWithName(elInclude, "namespace");
		for (Element namespaceElmnt : namespaceLst) {
			findClassesInNamespace(namespaceElmnt, classes);
		}
	}
}
